---
layout: note
title: PHP
categories: php
description: PHP
keywords: php
---





面试官好
我应聘的是贵公司的软件开发岗位，
我有五年开发经验，其中三年JAVA开发经验，两年PHP开发经验，曾经也使用过Python开发过网络爬虫，UniApp开发过小程序。也曾打造过一款月百万的APP，我对于各种常用的开发框架和编程语言，均有着深入的理解和实践经验。在面对陌生的编程语言时，能够迅速适应并掌握，迅速投入到新的工作项目中。我相信我能胜任贵公司的软件开发岗位，谢谢



#### PHP基本数据类型

整型（Integer）、浮点型（Double or float）、字符串（String）、空值（NULL）、布尔型（Boolean）、数组（array）、对象（Object）、资源（Resources）



#### 请描述static，self，parent关键字的用法

static关键字主要用来访问自身定义的静态成员

self关键字主要用来访问自身的方法和属性

parent关键字主要用来调用父类的方法和属性



#### isset和empty的区别

empty()会检测变量是否为空、为零。当一个变量值为0，或者为空字符串，empty()会返回TRUE。此外，如果变量未定义，empty()也会返回TRUE。

isset()用于检查变量是否已经设置，但是它不会检查变量是否为空或者为0。如果变量未定义，isset()会返回FALSE。



### error reporting 的作用

`error_reporting()`函数用于设置和获取当前的错误报告级别



#### 使用include和使用require引入文件的区别

错误处理：当文件不存在或无法被正确加载时，include语句会产生一个警告，并且脚本会继续执行。require语句会产生一个致命性错误，并且脚本会停止执行。

引用方式：include具有返回值，可以用于在引入文件后执行其返回的内容。require则没有返回值



#### 防止sql注入的方式

使用预处理语句

参数化查询：可以将用户提供的输入作为参数传递给数据库引擎，而不是将它们直接插入到SQL语句中

过滤输入数据：使用适当的过滤函数对用户输入进行验证



#### 什么是面向对象以及面向对象的主要特征

封装：隐藏内部的实现细节，只对外提供有限的接口。这种机制可以提高软件的模块化程度，降低维护成本，同时也增强了代码的可读性和可复用性。

继承：新类可以继承现有类的属性和方法。通过继承，我们可以在不重新编写原有代码的情况下，对其进行扩展和优化。这种机制可以节省开发时间，提高代码的可重用性和可维护性。

多态：多态是指在一个程序中，不同的对象可以对同一消息做出不同的响应。这种机制可以使程序更具有灵活性，能够轻松地应对需求的变化。



#### 常用的设计模式

1. 单例模式（Singleton）：确保一个类只有一个实例化对象。
2. 工厂模式（Factory）：将对象的实例化过程封装在一个工厂类中。
3. 抽象工厂模式（AbstractFactory）：是一种类似于工厂模式的创建对象的模式。
4. 观察者模式（Observer）：实现对象之间的一对多依赖关系。
5. 适配器模式（Adapter）：将一个类的接口转换成另一个类的接口。
6. 装饰器模式（Decorator）：动态地给一个对象添加一些额外的功能。
7. 迭代器模式（Iterator）：用于遍历一个聚合对象的元素。
8. 策略模式（Strategy）：用于定义一系列算法，并将每个算法封装起来，使它们可以互相替换。
9. 模板方法模式（Template Method）：定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。



#### 什么是类？类有什么特征

类是面向对象编程中，一种抽象的概念。是具有相同特征和行为的一组对象的集合。

类的特征主要有以下三个方面：

1. 封装性：将数据和操作封装为一个整体，通过方法进行交互，提高重用性和可靠性
2. 继承性：是一种类之间的层次关系，使得一个类可以继承另一个类的属性和方法，节省不必要的重复代码。
3. 多态性：同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果



#### MYSQL数据库存储引擎InnoDB和MyISAM区别？

事务支持：InnoDB支持事务，而MyISAM不支持

锁的粒度：InnoDB支持行级锁，而MyISAM只支持表级锁

数据恢复：InnoDB使用日志来恢复数据，这使得在系统崩溃或突然断电后可以恢复数据。而MyISAM没有这种功能，如果数据库文件丢失或被损坏，可能会导致数据丢失

索引和查询优化：InnoDB支持全文索引，适合进行复杂的搜索。而MyISAM仅支持简单的索引类型，对于复杂查询优化能力较弱

数据存储：InnoDB以聚集（clustered）方式存储数据，而MyISAM以非聚集（Non-clustered）方式存储数据

> Clustered索引是指在数据存储中，数据的物理顺序与索引的排序顺序一致。也就是说，如果数据在物理空间上是按照一定顺序存储的，那么使用Clustered索引能更加高效地查询这些数据。在每个表里，只能有一个Clustered索引，因为数据在存储时只能有一种物理顺序。在查找某个范围内的数据时，Clustered索引非常有效，因为这些数据在存储时已经按照物理顺序排好序了。
>
> Non-clustered索引则是数据存储的一种形式，它的物理存储和索引的排序顺序并不一致。Non-clustered索引不影响数据在物理存储上的排序，而是通过在数据行中存储指向实际数据的指针来创建索引。因此，Non-clustered索引可以创建在表中的任何列上，每个表可以有多个Non-clustered索引。由于Non-clustered索引不影响物理存储的顺序，因此其创建和删除不会造成额外的开销。但是，当插入、删除或更新行时，可能会影响到Non-clustered索引的效率，因为需要相应地更新指向数据的指针。



#### 写出5种以上的数据库优化建议？

选择适当的索引：根据查询中最常见的过滤条件、连接条件、排序条件或分组条件来选择建立索引

优化查询：尽量避免全表扫描，特别是对于大数据量的表

使用分区：可以将大型表分解为更小的表

优化数据类型：可以减少存储空间和提高查询性能

调整数据库参数：可以调整缓存大小、内存分配、并发连接数等

缓存查询结果：对于经常需要查询的结果，可以考虑将结果缓存起来

优化数据写入：对于读多写少的场景，可以考虑将写操作和读操作分开处理

使用预编译语句或存储过程：预编译语句或存储过程可以减少数据库执行查询所需的计算时间



#### psr2和psr4区别

PSR-2和PSR-4都是PHP标准的一部分，它们分别关注代码风格和自动加载标准。

PSR2是代码风格标准包括对缩进、命名空间、类和方法等的规定

PSR4是自动加载标准，它规定了如何自动加载PHP类，在`composer.json`下的`autoload`配置项



#### 如果一个访问量达到100万，选择缓存，你会选择redis还memchache

选择缓存方案，需要根据具体业务需求和应用场景来决定。

如果需要缓存的数据结构比较复杂，比如是哈希、列表、集合那么Redis会更合适，因为MemCache只支持简单的键值对（key-value）类型

如果需要缓存的数据需要进行持久化存储，那么Redis是更好的选择，因为MemCache不支持持久化



#### 设计一个秒杀系统，如何保证商品不超卖？

需要考虑几个关键因素：并发控制、库存管理和事务一致性

1. 并发控制：在并发场景下，为了防止超卖，需要对请求进行排队或者限流。一种常见的做法是利用分布式锁，如Redis或ZooKeeper，对秒杀商品进行原子性的读和写操作。当一个用户请求秒杀时，系统会尝试获取锁，如果获取成功，就进行秒杀操作，然后释放锁。如果获取锁失败（意味着有其他请求在处理秒杀或者库存不足），就返回秒杀失败的信息给用户
2. 库存管理：库存是秒杀系统的核心。一种常见的做法是预先将商品库存放入内存缓存中，当一个用户请求秒杀时，系统会尝试减库存。如果库存充足则进行秒杀，如果库存不足则返回秒杀失败的信息。为了保证数据的一致性，这个操作也需要是原子性的，可以通过数据库的事务或者乐观锁来实现。
3. 事务一致性：为了保证数据的一致性，秒杀操作应该在一个事务中进行。如果一个用户在秒杀开始后支付失败，我们希望他能重新尝试支付。这就需要利用数据库的事务回滚功能。当事务失败时，可以回滚秒杀操作，保证数据的一致性。



#### 乐观锁和悲观锁

乐观锁和悲观锁是两种解决并发场景下数据竞争问题的思想。

1. 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。乐观锁的实现方式主要有两种：CAS机制和版本号机制。
2. 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）。



#### PHP如何实现静态化

1. 手工静态化：创建静态页面模板、将动态数据插入静态模板、生成静态页面、使用PHP的文件操作函数将生成的静态页面写入磁盘

2. 使用框架自带的静态化：可以通过在框架配置中设置是否开启静态化功能，使用框架自带的静态化插件实现动态网页的静态转换



#### PHP四大排序算法？

冒泡排序：时间复杂度O(N2)	空间复杂度O(1)

选择排序：时间复杂度O(N2)	空间复杂度O(1)

插入排序：时间复杂度O(N2)	空间复杂度O(1)

快速排序：时间复杂度O(N*logN)	空间复杂度O(N)

另外还有归并排序、堆排序



#### PHP常见运行模式

CGI、FastCGI、Apache 、CLI、

CGI模式：将PHP解释器作为CGI程序运行，Web服务器会调用PHP解释器来执行PHP脚本，并将执行结果返回给浏览器。这种模式下的性能较低，因为每次都需要创建新的子进程来处理每个请求，当请求数量较多时，会占用大量系统资源，导致性能下降。

FastCGI（PHP-FPM）模式：FastCGI是一种改进的CGI模式，通过一个单独的FastCGI进程来处理PHP脚本。并且可以在每个请求之间缓存PHP脚本的执行结果，提高了性能和响应速度。适合处理大量的并发请求。

Apache模块（mod_php）模式：将PHP解释器嵌入到Apache Web服务器中，通过mod_php模块调用PHP脚本。这种模式下，PHP解释器和Apache服务器集成在一起，可以实现更高的性能和更好的安全性。mod_php模式无需使用CGI进程，直接通过Apache模块处理PHP脚本，因此比CGI模式更快、更高效。

CLI模式：PHP提供了一个命令行界面，可以在命令行下运行PHP脚本。这种模式下，PHP可以作为一个独立的脚本解释器来使用，可以用于执行各种系统管理任务、脚本编程和自动化任务等。CLI模式与前三者不同，它不适用于Web服务器环境，主要用于系统管理、命令行工具等场景。



#### PHP的优化方案

配置php.ini文件：调整内存限制、最大执行时间等参数

缓存页面和数据：对于静态内容，可以使用页面缓存。对于动态内容，可以使用数据缓存

异步处理和消息队列：对于一些耗时的任务，例如发送电子邮件或处理大量用户请求，可以使用异步处理和消息队列技术



#### session和cookie区别

Session存储在服务器端、Cookie则存储在客户端

Session的生命周期通常与用户会话相关，当用户关闭浏览器或会话结束后，Session中的信息会被清空。而Cookie的生命周期则可以根据设置而定，可以设置成会话结束时删除或保留一定时间。

Session相对较安全，因为它们存储在服务器端，不易被篡改或窃取。而Cookie则相对较不安全，因为它们存储在客户端，容易被用户禁用或清除，也容易被恶意攻击者窃取。



#### 如何实现不基于session和cookie的用户认证

令牌（Token）认证：当用户进行认证时，服务器生成一个唯一的令牌并返回给用户。用户在后续请求中需要携带该令牌，服务器通过验证令牌来判断用户身份。

第三方认证：如OAuth、JWT（JSON Web Token）等。这些第三方服务负责用户的认证和授权，并提供令牌或访问令牌给应用程序

API网关认证：API网关负责接收用户的请求，并转发给相应的后端服务。在转发之前，API网关可以验证用户的身份凭证，并将认证结果返回给请求方



#### 什么是CSRF攻击，XSS攻击？如何防范

XSS攻击，也称为跨站脚本攻击，是一种常见的网站应用程序安全漏洞攻击。攻击者在Web页面中嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而获取用户的敏感信息。这种攻击方式的根源在于没有处理好用户的输入，导致恶意脚本在浏览器中执行。

CSRF攻击，也被称为跨站请求伪造，通过冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）

对于XSS攻击的防范：对输入进行验证和过滤、转义字符、使用安全的框架和库

对于CSRF攻击的防范：验证请求来源、增加二次验证、限制操作频率



#### 设计模式六大原则

单一职责原则：简单来说，就是职责尽量单一

里氏替换原则：子类可以替换父类

依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体

接口隔离原则：通俗理解就是，不要再一个接口里放很多的方法，这样会显得这个类很臃肿。接口尽量细化，一个接口对应一个功能模块

迪米特法则：又叫最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解

开放关闭原则：对扩展开放，对修改关闭



#### PHP垃圾回收机制

从 PHP 5.3 版本开始，PHP 引入了一个新的垃圾回收机制，称为引用计数。

引用计数是一种简单的垃圾回收算法，它通过跟踪每个变量或对象的引用数来确定何时释放不再被引用的内存。当一个变量的引用数变为 0 时，表示没有任何代码引用该变量，它的内存就可以被释放。

从 PHP 7.0 版本开始，引入了一个新的垃圾回收机制，称为循环引用垃圾回收。循环引用垃圾回收机制可以解决引用计数无法处理循环引用的问题。



#### php魔术方法有哪些

PHP 魔术方法是在 PHP 中特殊的方法，它们具有在特定的时刻自动被调用的特性，这些方法包括：

- `__construct()`，类的构造函数，在对象创建时自动调用。
- `__destruct()`，类的析构函数，在对象销毁时自动调用。
- `__call()`，在对象中调用一个不可访问方法时自动调用。
- `__callStatic()`，用静态方式中调用一个不可访问方法时自动调用。
- `__get()`，获得一个类的成员变量时自动调用。
- `__set()`，设置一个类的成员变量时自动调用。
- `__isset()`，当对不可访问属性调用 isset() 或 empty() 时自动调用。
- `__unset()`，当对不可访问属性调用 unset() 时自动调用。
- `__clone()`，当对象复制完成时自动调用。
- `__autoload()`，尝试加载未定义的类。
- `__debugInfo()`，打印所需调试信息。



#### 什么是composer？composer的意义？工作原理

Composer代码依赖管理工具

Composer的意义在于简化PHP开发过程中的依赖管理，使得开发者能够更加高效地开发和维护PHP项目

Composer会根据项目的composer.json文件中的声明，解析并下载所需的依赖项及其依赖关系。这些依赖项将被安装到项目的“vendor”目录下，然后Composer将自动生成一个自动加载器，以便在代码中轻松地引用这些依赖项。



#### 框架的生命周期

1. **程序启动准备阶段**：这个阶段主要涉及到服务容器的实例化和基本注册
2. **请求实例化阶段**：这个阶段主要是将客户端发送的请求转化为一个实例对象
3. **请求处理阶段**：这个阶段主要是将请求实例通过中间件处理通过路由和控制器进行分发，使得不同的请求能通过相应的处理程序进行处理并生成响应
4. **响应发送和程序终止阶段**：这个阶段主要是完成响应的发送和程序的终止。响应的发送包括两部分内容：响应头信息的发送和响应主体内容的发送。程序的终止主要是完成终止中间件的调用。



#### 类的自动加载怎么实现

类的自动加载主要通过 Composer 和 PSR-4 标准来实现



#### composer的功能和实现

Composer是PHP的一个依赖管理工具，它主要的功能是协助开发者管理项目中的依赖关系，通过自动加载机制来实现代码的复用

实现方式主要是通过读取项目的composer.json文件来实现的。这个文件包含了项目的依赖关系和自动加载规则。执行Composer命令时，Composer会解析composer.json文件，然后根据文件中的信息下载和更新依赖库，并生成自动加载文件vendor/autoload.php



#### 路由是怎么实现的

1. 加载路由文件：加载位于`routes`目录下的路由文件
2. 定义路由：使用Route类提供的get、post、put、delete等方法来定义不同类型请求的路由，并指定相应的URI和处理程序
3. 处理请求：当一个请求到达服务器时，根据请求的URI和HTTP方法来查找相应的路由。如果找到匹配的路由，则执行该路由所指定的处理程序。
4. 返回响应：路由中的处理程序可以返回一个响应对象或一个字符串



#### 这个框架有什么优点

ThinkPHP、Laravel优点：简单快速易上手，强大的生态社区。

ThinkPHP、Laravel缺点：前后端完全分离的趋势下，前后端的耦合的还是有些重了。目录结构相对混乱，需要花时间整理才能更好地维护代码。

Yii2优点：

1. 性能优秀。相比 Laravel，Yii2 在处理高并发请求和复杂业务逻辑时有更好的性能，可以更快捷地处理大量数据。
2. 安全性高。Yii2 的安全性相对较高，具有 CSRF、XSS 防御、身份验证等安全机制，保护应用程序免受攻击。

Yii2缺点：

1. 学习曲线较陡峭。相比 Laravel，Yii2 的使用过程中需要更多的基础知识，学习门槛相对较高。
2. 难以定制。Yii2 不像 Laravel 那样简单易用，如果需要一个定制化的功能，需要逐层梳理代码才能进行修改。
3. 社区没有ThinkPHP、Laravel强大



#### 什么是MVC

MVC是模型（Model）、视图（View）、控制器（Controller）的简写。

它是一种软件设计规范，是将业务逻辑、数据、显示分离的方法来组织代码。

MVC不是一种设计模式，而是一种架构模式，主要作用是降低了视图与业务逻辑间的双向偶合。



#### 什么是依赖注入

依赖注入是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。

依赖注入可以消除编程代码之间的依赖性，使应用程序更易于管理和测试。



#### 模板引擎的原理

模板引擎的原理主要是将模板与数据相结合，生成动态页面。模板引擎会读取模板文件中的特定标记，并将这些标记替换为实际的数据或代码。

模板引擎的实现方式可以有多种。一些模板引擎使用双大括号（{{}}）语法来标记变量和表达式，而另一些模板引擎则使用自定义的标签。在执行模板时，模板引擎会解析模板文件，并根据标签将数据插入到模板中的相应位置。

除了变量和表达式外，模板引擎还可能包含条件判断和循环语句。一些模板引擎还支持继承和包含，允许模板文件引用其他模板文件，从而方便地组织和管理复杂的页面结构。

Laravel 框架中使用的模板引擎是 Blade

ThinkPHP内置了ThinkTemplate引擎作为其模板引擎



#### mysql里常用的存储引擎有哪些

1. **InnoDB**：这是MySQL的默认存储引擎。它提供了事务处理，同时具有提交、回滚和崩溃恢复能力。并允许您在事务进行时进行无锁读取。
2. **MyISAM**：这是MySQL以前的默认存储引擎，但它不支持事务处理。由于MyISAM不支持事务，所以它在需要高并发写入的环境中表现可能较差。
3. **Memory（Heap）**：此存储引擎将所有数据存储在RAM中，为读取操作提供了极快的速度。然而，它的数据在MySQL服务器关闭或者重启时将丢失，而且它不支持事务和行级锁定。
4. **CSV**：CSV存储引擎让你可以把数据以CSV格式存储在硬盘上，这使得MySQL数据库和其他应用更易于集成。
5. **Federated**：Federated存储引擎提供了在一个MySQL数据库服务器上访问位于另一个MySQL服务器上的表的能力。
6. **Archive**：Archive存储引擎用于存储和检索大量的数据，如归档数据或者历史数据。它使用gzip算法进行行级的压缩，以减小存储的空间。
7. **Blackhole**：Blackhole存储引擎接收并记录数据，但不会实际存储数据。它可以被用来在复制环境中测试主服务器的负载。
8. **NDB或NDBCluster**：NDB是MySQL Cluster数据库管理系统的存储引擎，主要用于分布式计算。



#### mysql何时考虑分库分表

1. 单表过大.
3. 数据库访问频率，某表数据访问频率高，单个数据库节点无法满足高并发需求
4. 业务拆分，当系统业务逻辑越来越复杂，不同业务之间的数据耦合度越来越低



#### mysql的索引原理

B-Tree索引的工作原理如下：

1. 索引首先将表中的键值进行排序，然后将这些键值存储在B-Tree数据结构中
2. 当进行查询操作时，MySQL会使用B-Tree索引找到与查询条件匹配的键值

哈希索引的工作原理：

1. 索引首先将表中的键值进行哈希计算，然后将这些哈希值存储在哈希表中
2. 当进行查询操作时，MySQL会使用哈希索引找到与查询条件匹配的哈希值



#### 哪些情况下索引会失效

1. 使用操作符"<>"、"<"或">"进行比较
2. 在索引列上使用函数，例如SUBSTR、DECODE、INSTR等
3. 在联合索引中，如果查询的条件没有按照联合索引的顺序进行
4. 字符型字段为数字时在where条件里不添加引号
5. 在查询中使用通配符（如LIKE 'abc%'）来匹配开头的字符
6. 隐式类型转换。比如你创建了一个索引用于字段A，但是在查询时你却使用了不匹配的类型B



#### binlog日志的作用

1. 数据恢复：因为Binlog详细记录了所有修改数据的SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据Binlog来回放历史数据。
2. 主从复制：如果想要做多机备份的业务，可以去监听当前写库的Binlog日志，同步写库的所有更改。



#### 怎么去搭建一个主从复制

搭建MySQL主从复制需要以下步骤：

1. 确保每台数据库上都已安装时间同步工具
2. 修改配置文件以完成时间同步
3. 开启主从复制功能



#### mysql的主从同步延迟的分析及解决方案

MySQL主从复制是一个常见的数据同步方案，它允许将一个MySQL主服务器的数据复制到一个或多个从服务器上。然而，主从复制过程中可能会出现延迟，即主从服务器之间的数据不同步。以下是对MySQL主从同步延迟的分析及解决方案：

1. 延迟原因分析：

   - 网络延迟：主从服务器之间的网络连接可能存在延迟，导致数据传输速度变慢，从而引起同步延迟。
   - 主服务器负载：如果主服务器处理大量写入操作或执行复杂查询，可能导致主从同步延迟。
   - 从服务器负载：从服务器的负载也可能导致同步延迟，例如从服务器处理大量查询或写入操作。
   - 数据量大：当主服务器处理大量数据写入或更新操作时，从服务器需要花费更多时间来处理这些变更，从而导致延迟。

2. 解决方案：

   - 分散负载：使用多个从服务器分担负载，以便减少单个从服务器的压力。可以考虑设置读写分离，将部分查询分散到从服务器上，降低主服务器的负载。

   - 调整主从配置参数：通过调整MySQL的主从复制配置参数（如binlog_format、binlog_row_image等），可以优化主从同步的性能。
   - 定期检查和清理数据：定期检查主从数据的一致性，并清理过期或无效的数据，以减少数据量对同步延迟的影响。
   - 使用中间件或代理：在主从之间引入中间件或代理层，以减轻主从服务器的负载，并提高数据同步的效率。
   - 优化网络连接：确保主从服务器之间的网络连接稳定，并尽量减少网络延迟
   - 优化主服务器性能：通过升级主服务器硬件、优化主服务器的查询和写入操作，以及定期进行数据库优化，可以提高主服务器的性能。
   - 优化从服务器性能：为从服务器提供足够的硬件资源，如内存和磁盘IO，以确保其能够快速处理数据同步和查询操作。

   

#### 主从同步的原理

MySQL主从同步的原理主要涉及两个步骤：

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。二进制日志是MySQL中用于记录数据库更改的日志文件，其中包含了对数据库进行增、删、改、插入等操作的信息，以及用户操作的SQL语句。
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。然后，从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。

这样，当主服务器发生故障或停机时，从服务器可以继续提供服务，保证网站数据库不宕机或者宕机之后能够快速恢复，从而提高数据的安全性。



#### 如何保障数据的可用性

保障数据的可用性是数据备份和恢复策略的核心目标。以下是一些保障数据可用性的方法：

- 定期备份数据。并将备份文件存储在多个位置，以确保即使发生硬件故障、网络中断或自然灾害等意外情况，也可以从备份中恢复数据
- 使用CDP备份和CDM备份（也叫合成备份、永久增量备份）。这种备份方式可以提供类似增量备份的数据量，但实现类似完全备份的效果，从而节省备份时间和存储空间。
- 为业务应用实施应用容灾。应用容灾是一种保护业务高可用的技术，通过在异地建立灾备中心，实现业务的实时切换



#### 即使被删库也能恢复到分钟级别怎么做

7. 查询是否开启 binlog 日志的 sql 脚本。
2. 查看binlog存放日志文件目录
3.  show variables like '%datadir%';

  恢复数据步骤：

1. 在mysql 安装目录 bin 目录中放入插件 my2sql，然后给 mysql 赋权限。
2. 创建一个空文件夹 “tmpdir”，然后给个 777 的权限。
3. 将binlog文件下载到本地，然后转换成sql格式，找到对应的节点（pos点），节点名（pos点）是纯数字的时间戳，根据节点可以恢复指定时间段的数据。
4. binlog 文件格式转换，首先保证本地数据库与生产环境数据库版本要一致，然后输入以下命令(不要有换行符号)：
5. 在bin目录，输入以下命令（不要有换行）：

　　　　./my2sql -user root -password 123456 -host 127.0.0.1 -port 3308 

　　　　-mode file -local-binlog-file ./mysql-bin.000038 -work-type 2sql 

　　　　-start-file mysql-bin.000038 -start-pos 606463342 -

　　　　stop-file mysql-bin.000038 -stop-pos 651675557 -output-dir ./tmpdir

1. 将提取出的文件，在文本编辑器中打开，检查对应的 sql 是否正确且完整，要注意 delete 与 rollback语句 。
2. sql 审查没问题了，然后在库里面将 sql 文件执行下就好了，推荐使用 navicat 15 工具，选运行 sql 文件来执行sql，到此，数据就算恢复完成了。



#### memcache和redis的区别

Memcache和Redis都是流行的服务端缓存技术，它们有以下区别：

1. 数据大小：Memcached单个key-value的大小有限，一个value最大只支持1MB，而Redis最大支持512MB。
2. 数据类型：Memcache只支持简单的数据类型，而Redis支持复杂的数据类型，如哈希、列表、集合和有序集合等。
3. 存储方式：Memcache把数据全部存在内存中，数据不能超过内存的大小，断电后数据库会挂掉。而Redis可以将部分数据存在硬盘上，这样即使在断电等异常情况下也能保证数据的持久性。
4. 可靠性：Memcached只是一个内存缓存，对可靠性没有要求。而Redis更倾向于内存数据库，因此对可靠性方面要求比较高。
5. 数据恢复：Memcache挂掉后，数据不可恢复。而Redis数据丢失后可以通过AOF日志恢复。



#### Redis的数据结构有哪些

1. **String**：这是Redis最基础的数据结构，可以用来存储简单的字符串或json格式的字符串
2. **Hash**：哈希表主要用于存储键值对
3. **List**：列表可以作为栈和队列使用，可以用来存储类似微信公众号，微博等消息流数据
4. **Set**：与列表类似，集合也可以存储多个元素，但集合中的元素不能重复
5. **Zset**：有序集合和集合类似，但有序集合中的元素是有序的



#### redis数据持久化有哪些方式及区别

Redis提供了两种主要的持久化方式：RDB（Redis Database）和AOF（Append-Only File）。

1. RDB持久化方式是Redis默认的持久化方式，通过将Redis的数据集快照写入磁盘文件来实现持久化。当触发某个条件时，Redis会创建一个子进程，该子进程负责将当前内存中的数据集以二进制形式写入磁盘文件。RDB文件是一个紧凑且经过压缩的二进制文件，可以表示Redis在某个时间点上的数据快照。它的优点在于RDB文件占用的磁盘空间相对较小，恢复大数据集时的速度较快，因为是通过加载整个数据集的二进制文件来完成。但缺点是在发生故障时可能会丢失最后一次快照之后的数据，并且在数据集较大时，RDB进程可能会占用较多的CPU和内存资源。
2. AOF持久化方式是Redis另一种持久化方式，原理是将Redis的操作日志以追加的方式写入文件。在Redis启动时，可以通过配置文件中的参数来决定是否开启AOF持久化功能。AOF持久化可以保证数据的完整性，即使在发生故障时也不会丢失数据。由于AOF持久化是通过记录所有的写操作来达到持久化的目的，因此在进行数据恢复时，可以更加快速地完成。但是AOF文件通常比RDB文件更大，且加载速度可能较慢。



#### 什么是缓存穿透

缓存穿透是指在高并发场景下，如果某一个key被高并发访问，没有被命中，出于对容错性考虑，会尝试去从后端数据库中获取，从而导致了大量请求到达数据库，而当该key对应的数据库本身就是空的情况下，这就导致数据库中并发的去执行了很多不必要的查询操作，从而导致巨大冲击和压力。

缓存穿透解决方案：

1. 缓存空对象：对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空的集合（非null）。这样避免请求穿透到后端数据库。同时，也需要保证缓存数据的时效性。这种方式实现起来成本较低，比较适合命中不高，但可能被频繁更新的数据。
2. 单独过滤处理：对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端数据库。这种方式实现起来相对复杂，比较适合命中不高，但是更新不频繁的数据。



#### 什么是缓存雪崩及解决方式

缓存雪崩是指缓存由于某些原因整体挂掉，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃。

缓存雪崩可能会发生的原因很多，例如缓存并发、缓存穿透和缓存颠簸等问题

解决缓存雪崩问题的方法包括以下几种：

1. 设置不同的过期时间：通过错开缓存过期时间，避免缓存集中失效导致请求大量到达后端数据库。
2. 使用双机房部署：将缓存集群部署在两个不同的机房，部分机器在一个机房，另一部分机器在另一个机房，以避免单个机房的缓存服务崩溃导致整个系统崩溃。
3. 使用两套Redis集群：将两套Redis集群之间做一个数据同步，以避免一个集群崩溃导致整个缓存服务失效。
4. 使用本地缓存：当源服务访问出现故障时，可以利用本地缓存支撑一阵，避免缓存服务彻底崩溃。
5. 对源服务访问进行限流、资源隔离（熔断）和Stubbed降级等措施，以避免大量请求直接打死mysql和源头服务。



#### 数据加密

1. MD5加密：
   将任意长度的数据转换成一个固定长度的哈希值。在PHP中，可以使用`md5()`函数对数据进行MD5加密。这种加密方式是单向的，无法解密，因此只能用于验证数据的完整性，而不能用于加密和解密数据。
2. SHA1加密：
   与MD5类似，它将数据转换为一个固定长度的哈希值。SHA1比MD5更安全，但计算开销也更大。在PHP中，可以使用`sha1()`函数对数据进行SHA1加密。同样，SHA1是单向的，无法解密。
3. 对称加密：
   对称加密使用相同的密钥进行加密和解密。在PHP中，常用的对称加密算法有AES（Advanced Encryption Standard）、DES等。可以使用`openssl`相关函数对数据进行对称加密。
4. 非对称加密：
   非对称加密使用公钥和私钥来进行加密和解密。在PHP中，常用的非对称加密算法是RSA（Rivest-Shamir-Adleman）。RSA对每个数据进行加密，然后接收方使用私钥进行解密。可以使用`openssl`相关函数对数据进行非对称加密。



#### jwt加密和rsa加密

JWT是一种开放标准（RFC 7519），用于在各方之间安全地传输信息。它基于使用Base64编码的JSON格式数据，通常由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。头部包含了关于JWT的元数据和加密算法的信息，例如加密算法为RS256。载荷包含了需要传输的数据，例如用户ID或其他声明。签名用于验证JWT的完整性。

RSA是一种非对称加密算法，使用一对密钥：公钥和私钥。公钥用于加密数据，只有拥有私钥的一方才能解密。私钥用于签名数据，只有拥有公钥的一方才能验证签名的有效性。RSA算法比较安全，难以破解，因此在许多场景中被广泛使用。

在微服务中，JWT和RSA加密可以结合使用。例如，在用户登录验证时，可以使用RSA算法将用户密码加密后存储在服务端，当用户进行登录时，再使用相同的算法解密并进行验证。同时，可以使用JWT来传输用户的身份信息和其他数据，以确保传输过程中的安全性。



#### nginx和apache的区别

1. 性能特性：Nginx被设计为轻量级的高性能Web服务器，其占用更少的内存和资源，这使得它能够处理更多的并发请求。相比之下，Apache是重量级的Web服务器，对高并发连接的支持较差。
2. 并发处理：Nginx使用异步非阻塞的方式来处理请求，这意味着它能够同时处理多个请求，而不会阻塞任何请求。相反，Apache处理请求的方式是阻塞的，这意味着在等待一个请求完成的同时，它会阻止其他请求的处理。因此，Nginx在处理高并发请求方面更具优势。
4. 与FastCGI的兼容性：Nginx友好支持FastCGI，这对于处理动态内容和高性能的Web应用（如PHP）非常有用。而Apache对FastCGI的支持则相对较差。

一般来说，对于需要处理高并发请求、动态内容和高性能Web应用场景，建议使用Nginx。如果需要处理大型和小型并发量、且有大量静态内容要处理的场景，Apache也是一个不错的选择。



#### nginx实现高并发的原理

Nginx实现高并发的原理基于其多进程（单线程）和多路IO复用模型。

Nginx使用I/O多路复用技术，能够并发地处理多个客户端请求。每个worker进程都是独立的，它们共同竞争来处理来自客户端的请求。worker进程数一般会设置成机器cpu核数，以充分利用系统资源。master进程充当整个进程组与用户的交互接口，同时对进程进行监护。当worker进程退出后（异常情况下），master进程会自动启动新的worker进程。

另外，Nginx使用异步非阻塞（AIO）的方式处理请求，即每个worker进程都可以同时处理多个请求，而不会阻塞任何请求。这意味着Nginx在高并发环境下能够更有效地利用系统资源，提高整体性能。

总的来说，Nginx通过多进程（单线程）和多路IO复用模型，以及异步非阻塞的处理方式，使其在高并发环境下表现出色。



#### linux的基本操作命令

1. 目录操作命令：cd、pwd、ls、mkdir、rmdir、du。
2. 文件操作命令：which、touch、cp、mv、rm、file。
3. 查看登录用户命令：who。
4. 系统管理类命令：shutdown、reboot、lscpu。
5. 日期时间管理类命令：date、clock。



#### 常用的查找和排序算法

1. **查找算法**：
   - 线性查找：从数组的起始元素开始逐个比较，直到找到目标元素
   - 二分查找：只适用于已经排序的数组，通过将目标元素与数组中间元素比较，每次可以排除一半的元素
   - 哈希查找：通过将目标元素映射到一个固定的位置来查找，时间复杂度为O(1)
   - 树查找：如二叉树、平衡二叉树、B树等，用于对大量数据进行高效查找
2. **排序算法**：
   - 冒泡排序：通过相邻元素比较和交换，使得每一轮循环后最大（或最小）的元素能浮动到数组的一端
   - 选择排序：每次从未排序的元素中选择最大（或最小）的元素，放到已排序序列的末尾
   - 插入排序：将未排序的元素逐个插入到已排序的序列中，直到所有元素都有序
   - 快速排序：通过一次分割将待排序数据分成两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按照此方法对这两部分数据分别进行快速排序，整个过程可以递归进行
   - 归并排序：采用分治法策略，将待排序序列分成若干子序列，分别进行排序，最后合并成一个有序序列
   - 堆排序：利用堆这种数据结构所设计的一种排序算法，堆是一个近似完全二叉树的结构



#### 什么是索引下推，索引覆盖，什么是回表？

1. 索引下推（Index Condition Pushdown，简称ICP）是一种优化数据库查询的技术，它利用了数据库索引的特性，在一定条件下，在索引层面就过滤掉不需要的数据，从而减少查询时需要访问的数据块，提高查询效率。在普通的查询中，数据库需要先从表中读取所有的数据记录，然后再根据查询条件过滤不需要的记录，最后返回查询结果。而在索引下推中，数据库会在索引树的节点上进行条件过滤，只将满足条件的数据块返回，而不是读取整个数据记录。这样可以避免从磁盘读取不必要的数据，降低IO开销，提升查询速度。
2. 回表（Table Disk I/O）是指通过索引查询出主键之后，还需要通过主键获取其他行字段的过程。例如，在执行“select name, age from t_test where name='a'”查询时，如果t_test表有一个组合索引（name），那么首先需要通过索引找到name='a'的记录的id，然后再通过id去表中获取age字段的值，这个获取数据的过程就是回表操作。回表操作会增加IO操作，降低查询效率。
3. 索引覆盖（Index Covering）是指查询字段包含在索引列里，直接通过索引树就能查询出需要的结果，不需要通过回表操作，减少磁盘IO次数。例如，某表有一个组合索引（name, age），如果查询只需要name和age字段，那么可以直接通过索引树查询得到结果，无需回表操作。



#### MySQL的索引，以及优缺点？

在MySQL中，有两种主要类型的索引：B-Tree索引和哈希索引。

B-Tree索引是一种自平衡树形数据结构，它按照顺序存储数据值，并使用搜索算法有效地查找、插入和删除数据。

哈希索引是一种基于哈希表的数据结构。它使用哈希函数将数据值映射到索引中。哈希索引主要用于等值查询，它不适用于范围查询和排序操作。

缺点：

1. 数据增删改需要设计索引的维护，当数据量大的情况下，索引的维护会带来较大的性能开销。
2. 一个表允许存在一个聚集索引和多个非聚集索引，但是索引不能创建太多，否则造成索引维护成本过高。
3. 创建索引要考虑字段值分散性，如果重复数据过多，创建索引反而会带来性能降低



#### MySQL事务的实现原理是什么？

MySQL事务的实现原理主要基于ACID特性（原子性、一致性、隔离性、持久性）和UndoLog机制。

1. ACID特性：
   - 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
   - 一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态。
   - 隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务是不可见的。
   - 持久性：一旦事务提交，其修改的效果就是永久性的，接下来即使系统崩溃也无法丢失。
2. UndoLog机制：

​		UndoLog是MySQL中实现事务回滚和数据恢复的重要机制。当事务开始时，MySQL会先创建一个UndoLog，记录这个事务对数据库做的所有修改。如果事务成功提交，那么这些修改会被持久化到数据库。如果事务回滚或者MySQL数据库崩溃，可以利用UndoLog对没有提交的事务进行回滚，保证数据库的数据一致性。

总之，MySQL事务的实现原理主要通过ACID特性和UndoLog机制来实现。



#### MySQL事务的隔离级别是什么？

在MySQL中，事务的隔离级别有四种，由低到高依次为读未提交、读已提交、可重复读、串行化，这些级别可以逐个解决脏读、不可重复读、幻读这几类问题。

1. 读未提交（Read uncommitted）：在这个隔离级别中，所有事务都可以看到其他未提交事务的执行结果。这个隔离级别可能导致脏读问题。
2. 读已提交（Read committed）：这个隔离级别中，一个事务提交之后，它修改的数据才会被其他事务看到。这个隔离级别可以解决脏读问题，但可能出现不可重复读和幻读问题。
3. 可重复读（Repeatable read）：在这个隔离级别下，一个事务在执行过程中看到的数据，总是和这个事务开启时看到的数据是一致的。这个隔离级别可以解决脏读和不可重复读问题，但可能出现幻读问题。
4. 串行化（Serializable）：这个隔离级别是最高的事务隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。然而，这个级别的代价也最高，性能很低，一般很少使用。



#### MySQL Update是行锁还是表锁？

MySQL的UPDATE操作既可以是行锁也可以是表锁，具体取决于执行UPDATE语句的条件、事务隔离级别等因素。

如果UPDATE语句中的WHERE条件包含索引列，那么执行UPDATE操作只会加行锁。如果WHERE条件中不包含索引列，那么执行UPDATE操作会加表锁。另外，根据查询范围的不同，MySQL也会选择不同粒度的锁。



#### LBCC和MVCC

LBCC和MVCC是两种用于并发控制的机制，为控制并发读写操作并保持数据的一致性。

**LBCC是基于锁的并发控制**。通过锁的粒度来进行并发控制。这种机制在锁的粒度过大时可能导致性能下降。

**MVCC是基于多版本的并发控制**。通过版本号，确保在高并发的情况下，多个事务读取数据的时候不加锁也可以多次读取相同的值，提高数据库的并发读写性能。它主要存在于InnoDB引擎下。



#### MVCC过程中会加锁吗？

**MVCC（多版本并发控制）过程中会加锁**。MVCC在并发控制策略上保持读不加锁的特性，但是在写操作时，会加上适当的锁来防止并发冲突。

在具体的操作中，当事务需要读取数据时，MVCC不会对数据加锁，这样读操作可以自由进行。然而，当事务需要修改数据时，MVCC会先获取一个写锁，再进行写操作。这样可以保证其他事务不能同时修改这部分数据，从而避免并发冲突。



#### MySQL如何解决幻读问题？

MySQL的InnoDB存储引擎通过MVCC（多版本并发控制）机制来解决幻读（Phantom Read）问题。

幻读是指在一个事务执行过程中，由于其他事务的插入或删除操作，会使得原本的事务看到了原本不存在的数据。

在InnoDB中，为了解决幻读问题，使用了以下技术：

1. 行级锁：InnoDB存储引擎实现了行级锁（row-level locking），通过锁定行数据，避免了多个事务同时操作同一行数据的问题。行级锁可以防止幻读现象的发生。
2. 间隙锁：InnoDB还实现了间隙锁（gap locking），它锁定的是一个范围而不是具体的行。间隙锁可以防止其他事务在这个范围插入新的数据，从而避免了幻读问题的发生。
3. 多版本并发控制（MVCC）：InnoDB使用MVCC机制来支持并发读取。每个事务在开始时都会获取一个唯一的事务ID（称为“版本号”），事务在读取数据时，会将这个版本号记录在数据行上。当其他事务修改或删除数据时，也会将自己的版本号记录在数据行上。这样，在事务结束时，如果版本号小于等于事务开始时的版本号，则说明这个事务读取到的数据是正确的，否则说明这个事务读取到了其他事务修改后的数据，产生了幻读。



#### 订单表每天新增500W数据分库分表如何设计？

提前规划分多少个库和多少个表，由于数据增量比较大，要避免分库分表后又出现容量满了的情况或者单表数据过大的问题，如果这个时候再去做容量扩充数据迁移和扩容的成本会非常高。

订单数据我们按照保留两年热数据来做计算，加一些空间预留，算出要分多少个库多少个表。

然后使用orderId作为分片键，采用一致性hash算法进行路由。

业务如果需要根据用户id查找，可以采用基因算法，来确保用户ID对应的订单ID路由到同一个库或同一个表。

在生成订单ID的时候把用户ID基因片段拼接到订单ID中，从而保证不管通过订单ID查询还是根据用户ID查询，都能路由到同一个表。

热数据保存一年，一年后迁移到历史库，历史库保存2两年，超过这个时间直接归档。

除了这个方案意外还可以采取HTAP存储方案，比如TiDB、PolorDB等等



#### Redis 看门狗机制

看门狗机制是Redis提供的一种自动延期机制，这个机制使得Redis提供的分布式锁是可以自动续期

看门狗机制提供的默认超时时间是30秒

如果一个线程获取锁后，运行程序到释放锁所花费的时间大于锁自动释放时间（也就是30s），那么Redis会自动给目标锁延长超时时间

在Redis中想要启动看门狗机制，那么我们就不要获取锁的时候自己定义`leaseTime(锁自动释放时间)`

如果自己定义了锁自动释放时间的话，无论是通过`lock`还是`tryLock`方法，都无法启用看门狗机制。

但是，如果传入的`leaseTime`为-1，也是会开启看门狗机制的



#### 你们系统是怎么实现分布式锁的？

我们使用了redis的分布式锁。具体做法是后端接收到请求后加入一个分布式锁，如果加锁成功，就执行业务，如果加锁失败就等待锁或者拒绝请求。业务执行完成后释放锁。使用SETNX命令。

**这样设置会不会有问题呢？如果加锁成功的客户端挂了怎么办？**

可以设置一个过期时间

**设置了过期时间，如果业务还没有执行完成，但是redis锁过期了，怎么办？**

需要对锁进行续约。设置锁成功后，启动一个watchdog，每隔一段时间(比如10s)为当前分布式锁续约，也就是每隔10s重新设置当前key的超时时间。使用：
EXPIRE命令

**watchdog怎么实现呢？**

当客户端加锁成功后，可以启动一个定时任务，每隔10s来检测业务是否处理完成，检测的依据就是判断分布式锁的key是否还存在，如果存在，就进行续约。

**如果当前线程已经处理完，这个key是被其他客户端写入的呢？**

可以为每个客户端指定一个clientID，在VALUE中增加一个clientID的前缀，这样在续锁的时候，可以判断当前分布式锁的value前缀来确定是不是当前客户端的，如果是再续锁，否则不做处理。

**你们的续锁功能是自己实现的吗？**

我们用的Redis的分布式锁方案

具体原理是：这个分布式锁超时时间默认是30秒(可以通过Config.lockWatchdogTimeout来修改)。加锁成功后，就会启动一个watchdog，watchdog是一个后台线程，会每隔10秒检查一下客户端是否还持有锁key，如果是，就延长锁key的生存时间，延长操作就是再次把锁key的超时时间设置成30s。



#### Redis里的定时器怎么实现的？

Redis定时器使用的是netty-common包中的HashedWheelTime来实现的。



#### 如果client1宕机了，这时分布式锁还可以续期吗？

因为分布式锁的续期是在客户端执行的，所以如果client1宕机了，续期线程就不能工作了，也就不能续期了。这时应该把分布式锁删除，让其他客户端来获取。



#### 那如果client1宕机了，其他客户端需要等待30s才能有机会获取到锁，有办法立刻删除锁吗？

因为client1宕机了，只能等到超时时间后锁被自动删除。如果要立刻删除，需要增加额外的工作，比如增加哨兵机制，让哨兵来维护所有redis客户端的列表。哨兵定时监控客户端是否宕机，如果检测到宕机，立刻删除这个客户端的锁



#### 如果不用Redis，怎么实现分布式锁的续锁

1. 加锁的命令，我们参照spring包里的分布式锁代码，如果锁存在并且是当前客户端加的锁，那就续锁，如果锁不存在，则加锁。
2. 把锁保存在一个数据结构里，比如HashMap，定时任务定时扫描这个map，对每个锁进行续锁操作。
3. 如果锁是当前客户端加的，那就续锁，否则失败
4. 写一个定时任务，定时执行续锁代码



#### MySQL索引类型

1. **主键索引**：每个表只能有一个主键索引，它不允许有空值。主键索引是为主键字段创建的索引，具有唯一性和非空性。
2. **唯一索引**：唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
3. **普通索引**：普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。
4. **全文索引**：全文索引类型为FULLTEXT，主要用于文本搜索。在定义索引的列上支持值得全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。
5. **组合索引**：组合索引指在表的多个字段组合上创建的索引。使用组合索引时遵循最左前缀集合。



#### SQL查询非常慢，如何优化

1. **优化查询语句本身**：检查查询语句是否可以进一步优化。使用EXPLAIN关键字排查。
2. **优化表结构**：检查表结构是否存在不合理的设计，例如过多使用NULL值、数据类型不匹配、索引设计不合理等。
3. **使用索引**：通过建立合适的索引。
4. **数据库参数调整**：根据数据库的配置，可以调整一些参数来提高查询性能。例如，增加缓存区大小（sort_buffer_size）和临时表大小（tmp_table_size）参数的值，可以加快ORDER BY和GROUP BY操作的速度。
5. **数据库硬件配置优化**：硬件配置也会影响查询性能。例如，增加内存容量、使用高性能的存储设备、优化网络带宽等都可以提高查询速度。
6. **合理利用缓存**：对于频繁查询的查询结果，可以将其缓存起来以避免重复查询。
7. **分页查询**：对于大量数据的分页查询操作，可以通过LIMIT和OFFSET分页来避免全表扫描。



算法题

面试题

PDF书籍

超级码客

英语句子翻译保存软件

