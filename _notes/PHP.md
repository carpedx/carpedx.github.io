---
layout: note
title: PHP
categories: php
description: PHP
keywords: php
---



#### PHP基本数据类型

1. 字符串（String）：表示文本数据，可以用单引号或双引号括起来。

2. 整数（Integer）：表示整数值，可以是正数、负数或零。

3. 浮点数（Float）：表示浮点数值，即带有小数部分的数值。

4. 布尔值（Boolean）：表示真或假的值，可以是true（真）或false（假）。

5. 数组（Array）：表示一个有序的集合，可以包含不同类型的元素。

6. 对象（Object）：表示一个自定义的数据结构，包含属性和方法。

7. 资源（Resource）：表示外部资源的引用，如数据库连接、文件句柄等。

8. 回调函数（Callback）：表示指向函数的引用，可用于回调机制。

9. 可调用（Callable）：表示可以被调用的实体，包括函数、方法、闭包等。

10. 迭代器（Iterator）：表示可遍历集合的对象，可以用于循环遍历。

11. 闭包（Closure）：表示一个匿名函数，可以作为参数传递或赋值给变量。



#### 请描述static，self，parent关键字的用法

1. static关键字主要用来访问类自身定义的静态成员
2. self关键字主要用来访问类自身的方法和属性
3. parent关键字主要用来调用父类的方法和属性

​    

#### isset和empty的区别

empty()会检测变量是否为空、为零。当一个变量值为0，或者为空字符串，empty()都会认为这个变量等于空。此外，如果变量未定义，empty()会返回TRUE。

isset()用于检查变量是否已经设置，但是它不会检查变量是否为空或者为0。如果变量未定义，isset()会返回FALSE。



### error reporting 的作用

`error_reporting()`函数用于设置和获取当前的错误报告级别



#### 使用include和使用require引入文件的区别

错误处理：当文件不存在或无法被正确加载时，include语句会产生一个警告，并且脚本会继续执行。然而，require语句会产生一个致命性错误，并且脚本会停止执行。

条件包含：include()是有条件包含函数，这意味着它只会在符合特定条件时才包含文件。而require()则是无条件包含函数，它会无条件地包含指定文件

引用方式：include具有返回值，可以用于在引入文件后执行其返回的内容。require则没有返回值



#### PHP防止sql注入的方式和函数有哪些

使用预处理语句：PDO是PHP中用于访问数据库的一种扩展，它支持预处理语句。MySQLi是MySQL的另一个扩展，它也支持预处理语句。

参数化查询：使用参数化查询，你可以将用户提供的输入作为参数传递给数据库引擎，而不是将它们直接插入到SQL语句中，从而避免SQL注入的风险

过滤输入数据：使用适当的过滤函数对用户输入进行验证



#### 什么是面向对象以及面向对象的主要特征

封装：隐藏内部的实现细节，只对外提供有限的接口。这种机制可以提高软件的模块化程度，降低维护成本，同时也增强了代码的可读性和可复用性。

继承：新类可以继承现有类的属性和方法。通过继承，我们可以在不重新编写原有代码的情况下，对其进行扩展和优化。这种机制可以节省开发时间，提高代码的可重用性和可维护性。

多态：多态是指在一个程序中，不同的对象可以对同一消息做出不同的响应。这种机制可以使程序更具有灵活性，能够轻松地应对需求的变化。



#### 常用的设计模式

1. 单例模式（Singleton）：确保一个类只有一个实例化对象。
2. 工厂模式（Factory）：将对象的实例化过程封装在一个工厂类中。
3. 抽象工厂模式（AbstractFactory）：是一种类似于工厂模式的创建对象的模式。
4. 观察者模式（Observer）：实现对象之间的一对多依赖关系。
5. 适配器模式（Adapter）：将一个类的接口转换成另一个类的接口。
6. 装饰器模式（Decorator）：动态地给一个对象添加一些额外的功能。
7. 迭代器模式（Iterator）：用于遍历一个聚合对象的元素。
8. 策略模式（Strategy）：用于定义一系列算法，并将每个算法封装起来，使它们可以互相替换。
9. 模板方法模式（Template Method）：定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。



#### 什么是类？类有什么特征

类是面向对象编程中，一种抽象的概念。是具有相同特征和行为的一组对象的集合。

类的特征主要有以下三个方面：

1. 封装性：将数据和操作封装为一个整体，通过方法进行交互，提高重用性和可靠性
2. 继承性：是一种类之间的层次关系，使得一个类可以继承另一个类的属性和方法，节省不必要的重复代码。
3. 多态性：同一操作作用于不同对象，可以有不同的解释，产生不同的执行结果



#### MYSQL数据库存储引擎InnoDB和MyISAM区别？

事务支持：InnoDB支持事务，而MyISAM不支持

锁的粒度：InnoDB支持行级锁，而MyISAM只支持表级锁

数据恢复：InnoDB使用日志（logging）和重做（redo）日志来恢复数据，这使得在系统崩溃或突然断电后可以恢复数据。而MyISAM没有这种功能，如果数据库文件丢失或被损坏，可能会导致数据丢失

索引和查询优化：InnoDB支持全文索引，适合进行复杂的搜索。而MyISAM仅支持简单的索引类型，对于复杂查询优化能力较弱

数据存储：InnoDB以聚集（clustered）方式存储数据，而MyISAM以非聚集（Non-clustered）方式存储数据

> Clustered索引是指在数据存储中，数据的物理顺序与索引的排序顺序一致。也就是说，如果数据在物理空间上是按照一定顺序存储的，那么使用Clustered索引能更加高效地查询这些数据。在每个表里，只能有一个Clustered索引，因为数据在存储时只能有一种物理顺序。在查找某个范围内的数据时，Clustered索引非常有效，因为这些数据在存储时已经按照物理顺序排好序了。
>
> Non-clustered索引则是数据存储的一种形式，它的物理存储和索引的排序顺序并不一致。Non-clustered索引不影响数据在物理存储上的排序，而是通过在数据行中存储指向实际数据的指针来创建索引。因此，Non-clustered索引可以创建在表中的任何列上，每个表可以有多个Non-clustered索引。由于Non-clustered索引不影响物理存储的顺序，因此其创建和删除不会造成额外的开销。但是，当插入、删除或更新行时，可能会影响到Non-clustered索引的效率，因为需要相应地更新指向数据的指针。



#### 写出5种以上的数据库优化建议？

选择适当的索引：根据查询中最常见的过滤条件、连接条件、排序条件或分组条件来选择建立索引

优化查询：尽量避免全表扫描，特别是对于大数据量的表

使用分区：可以将大型表分解为更小的表

优化数据类型：可以减少存储空间和提高查询性能

优化数据库结构：包括适当的数据规范化、实体关系建模、索引设计

调整数据库参数：可以调整缓存大小、内存分配、并发连接数等

缓存查询结果：对于经常需要查询的结果，可以考虑将结果缓存起来

优化数据写入：对于读多写少的场景，可以考虑将写操作和读操作分开处理。例如，可以设置一个专门的数据库服务器来处理写操作，以避免与读操作争抢资源。

使用预编译语句或存储过程：预编译语句或存储过程可以减少数据库执行查询所需的计算时间。



#### psr2和psr4区别

PSR-2和PSR-4都是PHP标准的一部分，它们分别关注代码风格和自动加载标准。

PSR2是代码风格标准包括对缩进、命名空间、类和方法等的规定

PSR4是自动加载标准，它规定了如何自动加载PHP类，在`composer.json`下的`autoload`配置项



#### 如果一个访问量达到100万，选择缓存，你会选择redis还memchache

选择缓存方案，需要根据具体业务需求和应用场景来决定。

如果需要缓存的数据结构比较复杂，比如是哈希、列表、集合那么Redis会更合适，因为MemCache只支持简单的键值对（key-value）类型

如果需要缓存的数据需要进行持久化存储，那么Redis是更好的选择，因为MemCache不支持持久化



#### 设计一个秒杀系统，如何保证商品不超卖？

需要考虑几个关键因素：并发控制、库存管理和事务一致性

1. 并发控制：在并发场景下，为了防止超卖，需要对请求进行排队或者限流。一种常见的做法是利用分布式锁，如Redis或ZooKeeper，对秒杀商品进行原子性的读和写操作。当一个用户请求秒杀时，系统会尝试获取锁，如果获取成功，就进行秒杀操作，然后释放锁。如果获取锁失败（意味着有其他请求在处理秒杀或者库存不足），就返回秒杀失败的信息给用户
2. 库存管理：库存是秒杀系统的核心。一种常见的做法是预先将商品库存放入内存缓存中，当一个用户请求秒杀时，系统会尝试减库存。如果库存充足则进行秒杀，如果库存不足则返回秒杀失败的信息。为了保证数据的一致性，这个操作也需要是原子性的，可以通过数据库的事务或者乐观锁来实现。
3. 事务一致性：为了保证数据的一致性，秒杀操作应该在一个事务中进行。如果一个用户在秒杀开始后支付失败，我们希望他能重新尝试支付。这就需要利用数据库的事务回滚功能。当事务失败时，可以回滚秒杀操作，保证数据的一致性。



#### PHP如何实现静态化

手工静态化：

创建静态页面模板

将动态数据插入静态模板

生成静态页面：使用PHP的文件操作函数将生成的静态页面写入磁盘

使用框架自带的静态化功：可以通过在框架配置中设置是否开启静态化功能，使用框架自带的静态化插件实现动态网页的静态转换



#### PHP四大排序算法？

冒泡排序：时间复杂度O(N2)	空间复杂度O(1)

选择排序：时间复杂度O(N2)	空间复杂度O(1)

插入排序：时间复杂度O(N2)	空间复杂度O(1)

快速排序：时间复杂度O(N*logN)	空间复杂度O(N)

另外还有归并排序、堆排序



#### PHP常见运行模式

CGI、FastCGI、Apache 、CLI、

CGI模式：将PHP解释器作为CGI程序运行，Web服务器会调用PHP解释器来执行PHP脚本，并将执行结果返回给浏览器。这种模式下的性能较低，因为每次都需要创建新的子进程来处理每个请求，当请求数量较多时，会占用大量系统资源，导致性能下降。

FastCGI（PHP-FPM）模式：FastCGI是一种改进的CGI模式，通过一个单独的FastCGI进程来处理PHP脚本。并且可以在每个请求之间缓存PHP脚本的执行结果，提高了性能和响应速度。适合处理大量的并发请求。

Apache模块（mod_php）模式：将PHP解释器嵌入到Apache Web服务器中，通过mod_php模块调用PHP脚本。这种模式下，PHP解释器和Apache服务器集成在一起，可以实现更高的性能和更好的安全性。mod_php模式无需使用CGI进程，直接通过Apache模块处理PHP脚本，因此比CGI模式更快、更高效。

CLI模式：PHP提供了一个命令行界面，可以在命令行下运行PHP脚本。这种模式下，PHP可以作为一个独立的脚本解释器来使用，可以用于执行各种系统管理任务、脚本编程和自动化任务等。CLI模式与前三者不同，它不适用于Web服务器环境，主要用于系统管理、命令行工具等场景。



#### PHP的优化方案

使用缓存

优化数据库访问

配置php.ini文件：调整内存限制、最大执行时间等参数

压缩输出内容：使用Gzip等压缩算法对输出内容进行压缩

缓存页面和数据：对于静态内容，可以使用页面缓存。对于动态内容，可以使用数据缓存

异步处理和消息队列：对于一些耗时的任务，例如发送电子邮件或处理大量用户请求，可以使用异步处理和消息队列技术



#### session和cookie区别

Session存储在服务器端、Cookie则存储在客户端

Session的生命周期通常与用户会话相关，当用户关闭浏览器或会话结束后，Session中的信息会被清空。而Cookie的生命周期则可以根据设置而定，可以设置成会话结束时删除或保留一定时间。

Session相对较安全，因为它们存储在服务器端，不易被篡改或窃取。而Cookie则相对较不安全，因为它们存储在客户端，容易被用户禁用或清除，也容易被恶意攻击者窃取。



#### 如何实现不基于session和cookie的用户认证

令牌（Token）认证：当用户进行认证时，服务器生成一个唯一的令牌并返回给用户。用户在后续请求中需要携带该令牌，服务器通过验证令牌来判断用户身份。

第三方认证：如OAuth、JWT（JSON Web Token）等。这些第三方服务负责用户的认证和授权，并提供令牌或访问令牌给应用程序

API网关认证：API网关负责接收用户的请求，并转发给相应的后端服务。在转发之前，API网关可以验证用户的身份凭证，并将认证结果返回给请求方



#### 什么是CSRF攻击，XSS攻击？如何防范

XSS攻击，也称为跨站脚本攻击，是一种常见的网站应用程序安全漏洞攻击。攻击者在Web页面中嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而获取用户的敏感信息。这种攻击方式的根源在于没有处理好用户的输入，导致恶意脚本在浏览器中执行。

CSRF攻击，也被称为跨站请求伪造，通过冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖、删帖、改密码、发邮件等）

对于XSS攻击的防范：对输入进行验证和过滤、转义字符、使用安全的框架和库

对于CSRF攻击的防范：验证请求来源、增加二次验证、限制操作频率



#### 设计模式六大原则

单一职责原则：简单来说，就是职责尽量单一

里氏替换原则：子类可以替换父类

依赖倒置原则：面向接口编程，依赖于抽象而不依赖于具体

接口隔离原则：通俗理解就是，不要再一个接口里放很多的方法，这样会显得这个类很臃肿。接口尽量细化，一个接口对应一个功能模块

迪米特法则：又叫最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解

开放关闭原则：对扩展开放，对修改关闭



#### PHP垃圾回收机制

从 PHP 5.3 版本开始，PHP 引入了一个新的垃圾回收机制，称为引用计数。

引用计数是一种简单的垃圾回收算法，它通过跟踪每个变量或对象的引用数来确定何时释放不再被引用的内存。当一个变量的引用数变为 0 时，表示没有任何代码引用该变量，它的内存就可以被释放。

从 PHP 7.0 版本开始，引入了一个新的垃圾回收机制，称为循环引用垃圾回收。循环引用垃圾回收机制可以解决引用计数无法处理循环引用的问题。



#### php魔术方法有哪些

PHP 魔术方法是在 PHP 中特殊的方法，它们具有在特定的时刻自动被调用的特性，这些方法包括：

- `__construct()`，类的构造函数，在对象创建时自动调用。
- `__destruct()`，类的析构函数，在对象销毁时自动调用。
- `__call()`，在对象中调用一个不可访问方法时自动调用。
- `__callStatic()`，用静态方式中调用一个不可访问方法时自动调用。
- `__get()`，获得一个类的成员变量时自动调用。
- `__set()`，设置一个类的成员变量时自动调用。
- `__isset()`，当对不可访问属性调用 isset() 或 empty() 时自动调用。
- `__unset()`，当对不可访问属性调用 unset() 时自动调用。
- `__clone()`，当对象复制完成时自动调用。
- `__autoload()`，尝试加载未定义的类。
- `__debugInfo()`，打印所需调试信息。



#### 什么是composer？composer的意义？工作原理

Composer代码依赖管理工具

Composer的意义在于简化PHP开发过程中的依赖管理，使得开发者能够更加高效地开发和维护PHP项目

Composer会根据项目的composer.json文件中的声明，解析并下载所需的依赖项及其依赖关系。这些依赖项将被安装到项目的“vendor”目录下，然后Composer将自动生成一个自动加载器，以便在代码中轻松地引用这些依赖项。



#### msyql的存储引擎，myisam和innodb区别

MySQL的两种主要存储引擎是MyISAM和InnoDB



#### 框架的生命周期

1. **程序启动准备阶段**：这个阶段主要涉及到服务容器的实例化和基本注册，包括服务容器本身的注册、基础服务提供者的注册、核心类别名的注册以及应用的基本路径注册。另外，这个阶段还涵盖了核心类的实例化，这是在服务容器实例化后，通过核心类别名注册服务得到的服务容器自动实例化对象。
2. **请求实例化阶段**：这个阶段主要是将客户端发送的请求转化为一个实例对象。Laravel通过Illuminate\Http\Request类的capture()静态方法来完成这个过程。
3. **请求处理阶段**：这个阶段首先是准备请求处理的环境，包括环境加载、服务提供者注册等环节，然后将请求实例通过中间件处理及通过路由和控制器进行分发控制，使得不同的请求能通过相应的处理程序进行处理并生成响应。
4. **响应发送和程序终止阶段**：这个阶段主要是完成响应的发送和程序的终止。响应的发送包括两部分内容：响应头信息的发送和响应主体内容的发送。程序的终止主要是完成终止中间件的调用。



#### 类的自动加载怎么实现

类的自动加载主要通过 Composer 和 PSR-4 标准来实现，在项目的根目录下，有一个名为 `composer.json` 的文件，该文件定义了项目的依赖关系和自动加载规则。另外还需要配置类的命名空间来组织类文件。



#### composer的功能和实现

Composer是PHP的一个依赖管理工具，它主要的功能是协助开发者管理项目中的依赖关系，通过自动加载机制来实现代码的复用

实现方式主要是通过读取项目的composer.json文件来实现的。这个文件包含了项目的依赖关系和自动加载规则。执行Composer命令时，Composer会解析composer.json文件，然后根据文件中的信息下载和更新依赖库，并生成自动加载文件vendor/autoload.php



#### 路由是怎么实现的

1. 加载路由文件：加载位于`routes`目录下的路由文件。这些文件包括`web.php`和`api.php`等，其中定义了不同路由的请求方式和相应的处理程序。
2. 定义路由：使用Route类提供的get、post、put、delete等方法来定义不同类型请求的路由，并指定相应的URI和处理程序。
3. 处理请求：当一个请求到达服务器时，根据请求的URI和HTTP方法来查找相应的路由。如果找到匹配的路由，则执行该路由所指定的处理程序。
4. 返回响应：路由中的处理程序可以返回一个响应对象或一个字符串。如果返回的是一个响应对象，Laravel会将其发送回客户端。如果返回的是一个字符串，Laravel会将其作为响应体发送回客户端。



#### 这个框架有什么优点

ThinkPHP、Laravel优点：简单快速易上手，强大的生态社区。

ThinkPHP、Laravel缺点：缺点前后端完全分离的趋势下，前后端的耦合的还是有些重了。目录结构相对混乱，需要花时间整理才能更好地维护代码。

Yii2优点：

1. 性能优秀。相比 Laravel，Yii2 在处理高并发请求和复杂业务逻辑时有更好的性能，可以更快捷地处理大量数据。
2. 安全性高。Yii2 的安全性相对较高，具有 CSRF、XSS 防御、身份验证等安全机制，保护应用程序免受攻击。
3. 多功能性。Yii2 提供了许多有用的工具、模型、插件等，开发者可根据自己的需求很快地构建出一个全栈 Web 应用程序。
4. 易于扩展。Yii2提供了一个强大的插件系统，开发者可以很容易地从社区中获取一个插件并集成到自己的代码中。
5. 模板模式。Yii2 的引擎已经集成了很多常见的文本和 HTML 模板，使得开发者可以快速定制自己的前端界面。

Yii2缺点：

1. 学习曲线较陡峭。相比 Laravel，Yii2 的使用过程中需要更多的基础知识，学习门槛相对较高。
2. 难以定制。Yii2 不像 Laravel 那样简单易用，如果需要一个定制化的功能，需要逐层梳理代码才能进行修改。
3. 部分文档需要改进。Yii2 文档、教程的一些质量还可以继续改进。



#### 什么是MVC

MVC是模型（Model）、视图（View）、控制器（Controller）的简写。它是一种软件设计规范，是将业务逻辑、数据、显示分离的方法来组织代码。MVC不是一种设计模式，而是一种架构模式，主要作用是降低了视图与业务逻辑间的双向偶合。



#### 什么是依赖注入

依赖注入是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。

依赖注入可以消除编程代码之间的依赖性，使应用程序更易于管理和测试。



#### 模板引擎的原理

模板引擎的原理主要是将模板与数据相结合，生成动态页面。模板引擎会读取模板文件中的特定标记，并将这些标记替换为实际的数据或代码。

模板引擎的实现方式可以有多种。例如，一些模板引擎使用双大括号（{{}}）语法来标记变量和表达式，而另一些模板引擎则使用自定义的标签。在执行模板时，模板引擎会解析模板文件，并根据标记或标签将数据插入到模板中的相应位置。

除了变量和表达式外，模板引擎还可能包含条件判断和循环语句。这些语句可以用于根据不同的条件或循环来生成不同的输出。一些模板引擎还支持继承和包含，允许模板文件引用其他模板文件，从而方便地组织和管理复杂的页面结构。

在生成最终的页面内容后，模板引擎可以通过输出到浏览器或保存到文件等方式将结果呈现给用户。

总的来说，模板引擎通过将模板与数据相结合，生成动态页面，简化了 Web 开发中页面生成的过程，提高了开发效率。

Laravel 框架中使用的模板引擎是 Blade，它主要用于将视图与 PHP 代码进行分离，提高代码的可读性和可维护性。

ThinkPHP内置了ThinkTemplate引擎作为其模板引擎。ThinkTemplate是ThinkPHP团队开发的一款简单、快速、轻量级的模板引擎，用于快速构建页面视图。

Yii2使用了基于PHP的模板引擎来实现视图渲染。



#### mysql里常用的存储引擎有哪些

1. **InnoDB**：这是MySQL的默认存储引擎。它提供了事务安全（ACID兼容）的存储，同时具有提交、回滚和崩溃恢复能力。InnoDB旨在处理大量数据的最大性能和并发性，它使用多版本并发控制（MVCC）以提高并发性，并允许您在事务进行时进行无锁读取。
2. **MyISAM**：这是MySQL以前的默认存储引擎，但它不支持事务处理。MyISAM提供了全文索引、压缩、空间函数等特性。由于MyISAM不支持事务，所以它在需要高并发写入的环境中表现可能较差。
3. **Memory（Heap）**：此存储引擎将所有数据存储在RAM中，为读取操作提供了极快的速度。然而，它的数据在MySQL服务器关闭或者重启时将丢失，而且它不支持事务和行级锁定。
4. **Federated**：Federated存储引擎提供了在一个MySQL数据库服务器上访问位于另一个MySQL服务器上的表的能力。
5. **CSV**：CSV存储引擎让你可以把数据以CSV格式存储在硬盘上，这使得MySQL数据库和其他应用更易于集成。
6. **Archive**：Archive存储引擎用于存储和检索大量的数据，如归档数据或者历史数据。它使用gzip算法进行行级的压缩，以减小存储的空间。
7. **Blackhole**：Blackhole存储引擎接收并记录数据，但不会实际存储数据。它可以被用来在复制环境中测试主服务器的负载。
8. **NDB或NDBCluster**：NDB是MySQL Cluster数据库管理系统的存储引擎，主要用于分布式计算。



#### mysql的索引原理

MySQL的索引是一种数据结构，它可以帮助数据库系统更快地查询和检索数据。

在MySQL中，索引主要有两种类型：B-Tree索引和哈希索引。其中B-Tree索引是最常见的索引类型，它使用B-Tree数据结构来存储索引数据。

B-Tree索引的工作原理如下：

1. 索引首先将表中的键值进行排序，然后将这些键值存储在B-Tree数据结构中。每个键值对应一个或多个数据记录的地址。
2. 当进行查询操作时，MySQL会使用B-Tree索引找到与查询条件匹配的键值。然后根据这些键值找到对应的数据记录。
3. 如果查询条件只涉及索引中的一部分键值，MySQL只需在B-Tree中搜索这些键值即可。如果查询条件涉及所有键值，MySQL需要搜索整个B-Tree。

哈希索引的工作原理与B-Tree索引不同。它使用哈希表来存储索引数据。哈希表是一种可以快速查找的数据结构，它通过将键值映射到哈希表中的位置来实现快速查找。

1. 索引首先将表中的键值进行哈希计算，然后将这些哈希值存储在哈希表中。每个哈希值对应一个或多个数据记录的地址。
2. 当进行查询操作时，MySQL会使用哈希索引找到与查询条件匹配的哈希值。然后根据这些哈希值找到对应的数据记录。



#### 哪些情况下索引会失效

索引在以下情况下可能会失效：

1. 违反了列上的某些约束条件，例如在 WHERE 子句中使用了不包含索引列的表达式。
2. 使用了不等于操作符（!= 或 <>），MySQL不会使用索引。
3. 在查询中使用了函数，这会使索引无效。例如，SELECT * FROM table WHERE YEAR(column) = 2010; 年份列上的索引不会被使用到。
4. 使用了不连续的列或者跳过的列，例如 SELECT * FROM table WHERE column1 = 1 AND column3 = 3; 即使 column1 和 column3 上有索引，MySQL 也可能不会使用它们。
5. 数据类型不匹配。在查询中，如果使用了不匹配的数据类型进行比较，那么索引将不会被使用。例如，如果列是 VARCHAR 类型，但是查询使用的是数字类型的数据，那么索引将不会被使用。
6. 使用了 OR 连接多个条件，而不是使用 UNION 或者 UNION ALL。如果每个条件都有自己的索引，但是使用了 OR 来连接它们，那么MySQL可能只会使用第一个条件的索引。
7. 对于联合索引，只有在查询条件中使用了联合索引的前缀列，才会使索引有效。例如，如果有一个联合索引是(a, b)，那么 SELECT * FROM table WHERE a = 1; 会使用索引，但是 SELECT * FROM table WHERE b = 1; 或者 SELECT * FROM table WHERE a = 1 AND b = 2; 不会使用索引。
8. 在查询中使用了 DISTINCT 关键字，也会使索引失效。
9. 对字符串列进行操作时，如果没有使用引号引起来，MySQL会将其视为一个常量，从而不会使用索引。
10. 对 NULL 值进行比较时，例如 SELECT * FROM table WHERE column IS NULL; 在 column 列上没有索引的情况下才会走全表扫描。



#### binlog日志的作用

1. 数据恢复：因为Binlog详细记录了所有修改数据的SQL，当某一时刻的数据误操作而导致出问题，或者数据库宕机数据丢失，那么可以根据Binlog来回放历史数据。
2. 主从复制：如果想要做多机备份的业务，可以去监听当前写库的Binlog日志，同步写库的所有更改。



#### 怎么去搭建一个主从复制

搭建MySQL主从复制需要以下步骤：

1. 确保每台数据库上都已安装时间同步工具。这可以通过命令“yum install ntp -y”来实现，但一般系统都是默认安装过的，还是安装一次确认一下为好。
2. 修改配置文件以完成时间同步。
3. 开启主从复制功能。



#### mysql的主从同步延迟的分析及解决方案

MySQL主从复制是一个常见的数据同步方案，它允许将一个MySQL主服务器的数据复制到一个或多个从服务器上。然而，主从复制过程中可能会出现延迟，即主从服务器之间的数据不同步。以下是对MySQL主从同步延迟的分析及解决方案：

1. 延迟原因分析：

   - 网络延迟：主从服务器之间的网络连接可能存在延迟，导致数据传输速度变慢，从而引起同步延迟。
   - 主服务器负载：如果主服务器处理大量写入操作或执行复杂查询，可能导致主从同步延迟。
   - 从服务器负载：从服务器的负载也可能导致同步延迟，例如从服务器处理大量查询或写入操作。
   - 数据量大：当主服务器处理大量数据写入或更新操作时，从服务器需要花费更多时间来处理这些变更，从而导致延迟。

2. 解决方案：

   - 优化网络连接：确保主从服务器之间的网络连接稳定，并尽量减少网络延迟。优化网络设备、增加带宽或使用更快的网络协议（如光纤）可以提高数据传输速度。
   - 优化主服务器性能：通过升级主服务器硬件、优化主服务器的查询和写入操作，以及定期进行数据库优化，可以提高主服务器的性能。
   - 优化从服务器性能：为从服务器提供足够的硬件资源，如内存和磁盘IO，以确保其能够快速处理数据同步和查询操作。
   - 分散负载：使用多个从服务器分担负载，以便减少单个从服务器的压力。可以考虑设置读写分离，将部分查询分散到从服务器上，降低主服务器的负载。
   - 调整主从配置参数：通过调整MySQL的主从复制配置参数（如binlog_format、binlog_row_image等），可以优化主从同步的性能。
   - 使用中间件或代理：在主从之间引入中间件或代理层，以减轻主从服务器的负载，并提高数据同步的效率。
   - 定期检查和清理数据：定期检查主从数据的一致性，并清理过期或无效的数据，以减少数据量对同步延迟的影响。

   

#### 主从同步的原理

MySQL主从同步的原理主要涉及两个步骤：

1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。二进制日志是MySQL中用于记录数据库更改的日志文件，其中包含了对数据库进行增、删、改、插入等操作的信息，以及用户操作的SQL语句。
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。然后，从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。

这样，当主服务器发生故障或停机时，从服务器可以继续提供服务，保证网站数据库不宕机或者宕机之后能够快速恢复，从而提高数据的安全性。



#### 是否会有不同步的情况，怎么办

**MySQL主从复制中可能会出现不同步的情况**。原因有很多，例如网络延迟、主从服务器负载不一致、数据量大等。

如果出现了不同步的情况，可以采取以下措施解决：

1. 检查主从库的配置参数。在MySQL中，主库将数据更新到二进制日志binlog中，而从库使用binlog来复制数据。要确保主从复制机制正常工作，需要检查数据库的复制机制是否存在异常。
2. 使用MySQL提供的工具修复不同步的数据。例如，“mysqldump”命令可以备份或还原数据，在某些情况下可以解决问题。还有一些其他工具，如“myisamchk”、“pt-table-checksum”等，也可以用来修复不同步的数据。
3. 优化慢查询。如果数据库中存在慢查询的情况，就会导致部分数据的修改延迟，影响数据同步。因此，需要定期优化数据库的慢查询，提高数据库的性能。



#### 如何保障数据的可用性

保障数据的可用性是数据备份和恢复策略的核心目标。以下是一些保障数据可用性的方法：

- 制定并执行灾难恢复计划。灾难恢复计划包括预先制定好的步骤和措施，旨在在最短的时间内恢复业务运营。制定灾难恢复计划需要考虑多种因素，包括恢复时间目标（RTO）和恢复点目标（RPO）。这些目标定义了哪些数据需要存储以及何时存储，以便在发生中断时可以轻松恢复操作。
- 定期备份数据。备份是保障数据可用性的关键。应定期备份所有数据，并将备份文件存储在多个位置，以确保即使发生硬件故障、网络中断或自然灾害等意外情况，也可以从备份中恢复数据。
- 使用适当的存储设备。选择可靠的存储设备，并使用RAID等存储技术来保护数据。RAID可以提供冗余和容错功能，从而提高数据可用性。
- 使用CDP备份和CDM备份（也叫合成备份、永久增量备份）。这种备份方式可以提供类似增量备份的数据量，但实现类似完全备份的效果，从而节省备份时间和存储空间。
- 为业务应用实施应用容灾。应用容灾是一种保护业务高可用的技术，通过在异地建立灾备中心，实现业务的实时切换。



#### 即使被删库也能恢复到分钟级别怎么做

要做到在被删库后也能恢复到分钟级别，可以参考以下步骤：

1. 备份：首先备份数据库，避免在操作过程中发生错误导致数据丢失。
2. 选择一个可靠的数据库恢复工具，例如Percona Data Recovery Tool for MySQL，它可以用于恢复被删除的MySQL数据库。
3. 停止数据库服务：在进行恢复操作时，需要先停止数据库服务，以防止数据被修改或覆盖。
4. 进入恢复模式：使用恢复工具进入恢复模式，根据提示进行操作。
5. 选择备份文件：选择之前备份的数据库文件，并将其提供给恢复工具。
6. 恢复数据库：让恢复工具自动进行数据库恢复操作，等待其完成恢复。
7. 检查数据：在数据库恢复完成后，检查数据是否完整，以确保恢复成功。



用过哪些nosql举例他们的使用场景

memcache和redis的区别

Redis的数据结构有哪些

redis数据持久化有哪些方式及区别

什么是缓存穿透

什么是缓存雪崩

及解决方式



数据接口的加密原理

实现方式和理解

自己常用的加密方式

是否了解对称加密和不对称加密

是否了解市面上主流的jwt加密和rsa加密

nginx和apache的区别

nginx实现高并发的原理

linux的基本操作命令等



常用的查找和排序算法